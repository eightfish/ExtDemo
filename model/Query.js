/*
 * File: app/model/Query.js
 *
 * This file was generated by Sencha Architect version 2.2.2.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 4.1.x library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 4.1.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('EvolveQueryEditor.model.Query', {
    extend: 'Ext.Base',

    requires: [
        'EvolveQueryEditor.model.ReportTypeModel',
        'EvolveQueryEditor.model.ProductModel',
        'EvolveQueryEditor.model.FilterModel',
        'EvolveQueryEditor.model.FilterValueModel',
        'EvolveQueryEditor.model.OutputFieldModel',
        'EvolveQueryEditor.store.QueryContextStore',
        'EvolveQueryEditor.store.ProductStore',
        'EvolveQueryEditor.store.MandatoryFieldsStore'
    ],
    singleton: true,
    tableCode: '',
    tableName: '',
    tableNamePlusCode: '',
    outputFieldsStore: undefined,

    getFilters: function () {
        var filtersRet = [];
        if (EvolveQueryEditor.model.Query.filtersStore != undefined) {
            for (var i = 0; i < EvolveQueryEditor.model.Query.filtersStore.count() ; i++) {
                var filter = EvolveQueryEditor.model.Query.filtersStore.getAt(i);
                if (filter.get('codePath') != "TABLE") {
                    if ((filter.get('from') != undefined) && (filter.get('superFieldFilter') == true)) {
                        filtersRet.push({
                            codePath: filter.get('codePath'),
                            valueFrom: filter.get('from'),
                            valueTo: filter.get('to'),
                            operator: filter.get('operator'),
                            mode: filter.get('mode'),
                            caseSens: filter.get('caseSens'),
                            segment: filter.get('segment'),
                            segmentOffset: filter.get('segmentOffset'),
                            segmentLength: filter.get('segmentLength')
                        });
                    }
                }
            }
        }

        return filtersRet;
    },

    getOutputFieldsStore: function () {
        if (this.outputFieldsStore == undefined) {
            this.outputFieldsStore = Ext.create('Ext.data.Store', {
                storeId: 'outputFieldsStore',
                model: "EvolveQueryEditor.model.OutputFieldModel",
                proxy: {
                    type: 'memory',
                    reader: {
                        type: 'json',
                        root: 'items'
                    }
                }
            });
        }

        return this.outputFieldsStore;
    },

    getProductCode: function(){
        return this.product === undefined ? undefined : this.product.data.Code;//this.product.get('Code');
    },

    getQueryType: function () {
        return this.reportType === undefined ? undefined : this.reportType.data.Type;// this.reportType.get("Type");
    },

    setTable: function (code, value, tableNamePlusCode) {
        for (var i = 0; i < EvolveQueryEditor.model.Query.filtersStore.count() ; i++) {
            var filter = EvolveQueryEditor.model.Query.filtersStore.getAt(i);
            if (filter.get('codePath') === "TABLE") {
                var model = EvolveQueryEditor.model.Query;
                // Create a model to hold the selection ...
                var modelSelection = Ext.create('EvolveQueryEditor.model.FilterValueModel', {
                    codePath: code,
                    valueFrom: code,
                    valueTo: code
                });

                filter.beginEdit();
                filter.setValue(modelSelection);
                filter.set('hasValue', true);
                filter.set('from', value);
                filter.set('to', value);
                filter.endEdit();

                model.tableCode = code;
                model.tableName = value;
                model.tableNamePlusCode = tableNamePlusCode;
                break;
            }
        }
    },

    stringIsEmpty: function (val) {
        return (val === undefined || val == null || val.length <= 0) ? true : false;
    },

    filterToFormula: function (filter) {
        var codePath = filter.get('codePath');
        var from = filter.get('from');
        var to = filter.get('to');
        if (this.stringIsEmpty(to)) {
            return Ext.String.format("F={0},K={1}", from, codePath);
        } else {
            return Ext.String.format("F={0},T={1},K={2}", from, to, codePath);
        }
    },

    outputFieldToFormula: function (outputField) {
        //template:E={0},X=<sFm2>{{_sf_}}{1}</sFm2>,S={2},O={3}"

        var extractValue = outputField.get("extractType");
        if (extractValue === "IS_SEGMENT") {
            //Segment will be 10203 if the offset is 2 and length is 3.
            extractValue += outputField.get("segmentOffset") * 100;
            extractValue += outputField.get("segmentLength");
        }
        //If ReverseSign is true, the - will be added. for example, -2.
        var extractionTypeWithReverseSign = Ext.String.format("{0}{1}", outputField.get("reverseSign") ? "-" : "", extractValue);

        var scalingFactor = outputField.get("scalingFactor");

        var sortIndexWithSortMode = "";

        var sortIndex = outputField.get("sortIndex");
        if (sortIndex === 0) {
            //for those fields in summary/detail link and none-sorting fields in summary/detail report, sortIndex=0 ,sortIndex part should not exist in formula.
        }
        else {
            //SortMode=ascending,sortIndex=2,sortIndexWithSortMode=2
            //SortMode=descending,sortIndex=2,sortIndexWithSortMode=(2)
            if (outputField.get("sortMode") == "IS_DESCENDING") {
                sortIndexWithSortMode = Ext.String.format("({0})", sortIndex);
            }
            else {
                sortIndexWithSortMode = Ext.String.format("{0}", sortIndex);
            }
        }

        var ret = Ext.String.format("{0}{1}{2}{3}", Ext.String.format("E={0},", extractionTypeWithReverseSign), this.stringIsEmpty(scalingFactor) ? "" : Ext.String.format("X=<sFm2>{{_sf_}}{0}</sFm2>,", scalingFactor), this.stringIsEmpty(sortIndexWithSortMode) ? "" : Ext.String.format("S={0},", sortIndexWithSortMode), Ext.String.format("O={0}", outputField.get("codePath")));
        return ret;
    },

    queryToFormula: function () {
        var query = this;
        var ret = Ext.String.format("{0},{1},{2},{3},", "1", "2", query.getProductCode(), query.tableCode);

        var filtersStore = query.filtersStore;
        for (var i = 0; i < filtersStore.count() ; i++) {
            var filter = filtersStore.getAt(i);
            if (filter.get('codePath') != "TABLE") {
                ret += Ext.String.format("{0},", this.filterToFormula(filter));
            }
        }
        var outputFieldsStore = query.getOutputFieldsStore();
        for (var i = 0; i < outputFieldsStore.count() ; i++) {
            var outputField = outputFieldsStore.getAt(i);
            ret += Ext.String.format("{0},", this.outputFieldToFormula(outputField));
        }

        return Ext.String.format("={0}(\"{1}{2}\",{3})", this.reportType.toFormula(), ret, "RT=-4154,RF=111111011,AF=1,TP=,", "");
    },

    removeQuoteIfPossible: function(value){
        if (value !== undefined && value.indexOf("'") === 0 && value.length > 1) {
            return value.substring(1);
        } else {
            return value;
        }
    },

    queryFromFormula: function (formula) {
        var me = this;

        var matches = formula.match(/=(.+)\(\"=(.+)\)/);
        if (matches.length === 3) {
            this.reportType = EvolveQueryEditor.model.ReportTypeModel.getReportType(matches[1]);
            var matches1 = matches[2].match(/(\d+),(\d+),(\w+),(\w+)(?:,\*={P}1|,\*=[YNyn])?(?:,(F=[^,]+,(?:T=[^,]+,)?K=[^,]+))*,?(?:,((?:C=[^,]+?,)?E=-?\d+,(?:X=<sFm2>{_sf_}[\+\-\/\*]\d+(?:\.\d+)?<\/sFm2>,)?(?:S=\(?\d+\)?,)?O=[^,]+))+(,RT=(-?\d)+,RF=([0-1]{9})(?:,AF=[01])?)?(,TP=(\d+%?)?)?(,XLBVal:(\d+)=(.*))?/);

            this.product = Ext.create('EvolveQueryEditor.model.ProductModel', {
                Code: matches1[3]
            });
            
            var filtersStore = EvolveQueryEditor.model.Query.getFilterStore();
            filtersStore.removeAll();

            //Set table code firstly, so that the following steps can use the table code to take the query. For example, loading the selection list. Otherwsie, the table code will be set in callback after retrieving the super filters.
            // We can now add the table filter ...
            var modelTable = Ext.create('EvolveQueryEditor.model.FilterModel', {
                name: 'Table',
                codePath: 'TABLE',
            });
            filtersStore.add(modelTable);
            EvolveQueryEditor.model.Query.setTable(matches1[4], matches1[4], matches1[4]);

            //Add super filters
            EvolveQueryEditor.model.Query.getSuperFiltersStore(function (records) {
                var matches2 = matches[2].match(/(F=[^,]+,(?:T=[^,]+,)?K=[^,]+)/g);
                var map = new Ext.util.HashMap();
                for(var i=0; i<matches2.length; i++){
                    var matches3 = matches2[i].match(/F=([^,]+),(?:T=([^,]+),)?K=([^,]+)/);
                    map.add(matches3[3], { from: me.removeQuoteIfPossible(matches3[1]), to: me.removeQuoteIfPossible(matches3[2]) })
                }
                for (var rowIndex = 0; rowIndex < records.length; rowIndex++) {
                    if (records[rowIndex].get('from') == '') {
                        records[rowIndex].set('from', undefined);  // No default - so make it really no value
                    }
                    if(map.get(records[rowIndex].get('codePath')) !== undefined){
                        records[rowIndex].set('from', map.get(records[rowIndex].get('codePath')).from);
                        records[rowIndex].set('to', map.get(records[rowIndex].get('codePath')).to);
                    }
                    records[rowIndex].set('superFieldFilter', true);
                    filtersStore.insert(rowIndex, records[rowIndex]);
                }

 
                //Add filters
                EvolveQueryEditor.model.Query.getMandatoryFiltersStore(function (rs) {
                    for (var row = 0; row < rs.length; row++) {
                        if (rs[row].get('from') == '') {
                            rs[row].set('from', undefined);  // No default - so make it really no value
                        }
                        if (map.get(rs[row].get('codePath')) !== undefined) {
                            rs[row].set('from', map.get(rs[row].get('codePath')).from);
                            rs[row].set('to', map.get(rs[row].get('codePath')).to);
                        }
                        filtersStore.add(rs[row]);
                    }
                });
            });

            return true;
        }

        return false;
    },

    getProductStore: function () {
        if (EvolveQueryEditor.model.Query.getQueryType() !== undefined && EvolveQueryEditor.store.ProductStore.Instance.count() === 0) {
            EvolveQueryEditor.store.ProductStore.Instance.load({
                callback: function (records, operation, success) {
                }
            });
        }

        return EvolveQueryEditor.store.ProductStore.Instance;
    },

    getSuperFiltersStore: function(callbackAfterLoad){
        if (EvolveQueryEditor.model.Query.getProductCode() !== undefined && EvolveQueryEditor.store.SuperFieldsStore.Instance.count() === 0) {
            EvolveQueryEditor.store.SuperFieldsStore.Instance.load({
                callback: function (records, operation, success) {
                    callbackAfterLoad(records);
                }
            });
        }

        return EvolveQueryEditor.store.SuperFieldsStore.Instance;
    },

    getMandatoryFiltersStore: function (callbackAfterLoad) {
        if (EvolveQueryEditor.model.Query.getProductCode() !== undefined && EvolveQueryEditor.model.Query.tableCode !== undefined && EvolveQueryEditor.store.MandatoryFieldsStore.Instance.count() === 0) {
            EvolveQueryEditor.store.MandatoryFieldsStore.Instance.load({
                callback: function (records, operation, success) {
                    callbackAfterLoad(records);
                }
            });
        }

        return EvolveQueryEditor.store.MandatoryFieldsStore.Instance;
    },

    getFilterStore: function () {
        if (EvolveQueryEditor.model.Query.filtersStore === undefined) {
            EvolveQueryEditor.model.Query.filtersStore = Ext.create('EvolveQueryEditor.store.QueryContextStore');
        }
        return EvolveQueryEditor.model.Query.filtersStore;
    }
});