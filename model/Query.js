/*
 * File: app/model/Query.js
 *
 * This file was generated by Sencha Architect version 2.2.2.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 4.1.x library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 4.1.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('EvolveQueryEditor.model.Query', {
    extend: 'Ext.Base',

    requires: [
        'EvolveQueryEditor.model.ReportTypeModel',
        'EvolveQueryEditor.model.ProductModel',
        'EvolveQueryEditor.model.FilterModel',
        'EvolveQueryEditor.model.FilterValueModel',
        'EvolveQueryEditor.model.OutputFieldModel',
        'EvolveQueryEditor.store.QueryContextStore',
        'EvolveQueryEditor.store.ProductStore',
        'EvolveQueryEditor.store.MandatoryFieldsStore',
        'EvolveQueryEditor.model.SortingTypeModel',
        'EvolveQueryEditor.model.OutputFieldModel'
    ],
    singleton: true,
    tableCode: '',
    tableName: '',
    tableNamePlusCode: '',
    outputFieldsStore: undefined,

    getFilters: function () {
        var filtersRet = [];
        if (EvolveQueryEditor.model.Query.filtersStore != undefined) {
            for (var i = 0; i < EvolveQueryEditor.model.Query.filtersStore.count() ; i++) {
                var filter = EvolveQueryEditor.model.Query.filtersStore.getAt(i);
                if (filter.get('codePath') != "TABLE") {
                    if ((filter.get('from') != undefined) && (filter.get('superFieldFilter') == true)) {
                        filtersRet.push({
                            codePath: filter.get('codePath'),
                            valueFrom: filter.get('from'),
                            valueTo: filter.get('to'),
                            operator: filter.get('operator'),
                            mode: filter.get('mode'),
                            caseSens: filter.get('caseSens'),
                            segment: filter.get('segment'),
                            segmentOffset: filter.get('segmentOffset'),
                            segmentLength: filter.get('segmentLength')
                        });
                    }
                }
            }
        }

        return filtersRet;
    },

    isAllSuperFieldFiltersSet: function () {
        if (EvolveQueryEditor.model.Query.filtersStore != undefined) {
            for (var i = 0; i < EvolveQueryEditor.model.Query.filtersStore.count() ; i++) {
                var filter = EvolveQueryEditor.model.Query.filtersStore.getAt(i);
                if (filter.get('superFieldFilter') === true && filter.get('from') === undefined) {
                    return false;
                }
            }
        }

        return true;
    },

    getOutputFieldsStore: function () {
        if (this.outputFieldsStore == undefined) {
            this.outputFieldsStore = Ext.create('Ext.data.Store', {
                storeId: 'outputFieldsStore',
                model: "EvolveQueryEditor.model.OutputFieldModel",
                proxy: {
                    type: 'memory',
                    reader: {
                        type: 'json',
                        root: 'items'
                    }
                }
            });
        }

        return this.outputFieldsStore;
    },

    getProductCode: function(){
        return this.product === undefined ? undefined : this.product.data.Code;//this.product.get('Code');
    },

    getQueryType: function () {
        return this.reportType === undefined ? undefined : this.reportType.data.Type;// this.reportType.get("Type");
    },

    setTable: function (code, value, tableNamePlusCode) {
        for (var i = 0; i < EvolveQueryEditor.model.Query.filtersStore.count() ; i++) {
            var filter = EvolveQueryEditor.model.Query.filtersStore.getAt(i);
            if (filter.get('codePath') === "TABLE") {
                var model = EvolveQueryEditor.model.Query;
                // Create a model to hold the selection ...
                var modelSelection = Ext.create('EvolveQueryEditor.model.FilterValueModel', {
                    codePath: code,
                    valueFrom: code,
                    valueTo: code
                });

                filter.beginEdit();
                filter.setValue(modelSelection);
                filter.set('hasValue', true);
                filter.set('from', value);
                filter.set('to', value);
                filter.endEdit();

                model.tableCode = code;
                model.tableName = value;
                model.tableNamePlusCode = tableNamePlusCode;
                break;
            }
        }
    },

    stringIsEmpty: function (val) {
        return (val === undefined || val == null || val.length <= 0) ? true : false;
    },

    filterToFormula: function (filter) {
        var codePath = filter.get('codePath');
        var from = filter.get('from');
        var to = filter.get('to');
        if (this.stringIsEmpty(to)) {
            return Ext.String.format("F={0},K={1}", from, codePath);
        } else {
            return Ext.String.format("F={0},T={1},K={2}", from, to, codePath);
        }
    },

    outputFieldToFormula: function (outputField) {
        //template:E={0},X=<sFm2>{{_sf_}}{1}</sFm2>,S={2},O={3}"

        var extractValue = outputField.get("extractType");
        var extractIntValue = extractValue.get('intValue');
        if (extractValue === EvolveQueryEditor.model.ExtractionTypeModel.Segment) {
            //Segment will be 10203 if the offset is 2 and length is 3.
            extractIntValue += outputField.get("segmentOffset") * 100;
            extractIntValue += outputField.get("segmentLength");
        }
        //If ReverseSign is true, the - will be added. for example, -2.
        var extractionTypeWithReverseSign = Ext.String.format("{0}{1}", outputField.get("reverseSign") ? "-" : "", extractIntValue);

        var scalingFactor = outputField.get("scalingFactor");

        var sortIndex = outputField.get("sortIndex");        
        var sortingFormulaPart = outputField.get("sortingType").toFormula(sortIndex);
        if(sortingFormulaPart !== '') { 
            sortingFormulaPart = sortingFormulaPart + ",";
        }
        
        var ret = Ext.String.format("{0}{1}{2}{3}", Ext.String.format("E={0},", extractionTypeWithReverseSign), this.stringIsEmpty(scalingFactor) ? "" : Ext.String.format("X=<sFm2>{{_sf_}}{0}</sFm2>,", scalingFactor), sortingFormulaPart, Ext.String.format("O={0}", outputField.get("codePath")));
        return ret;
    },

    queryToFormula: function () {
        var query = this;
        var ret = Ext.String.format("{0},{1},{2},{3},", "1", "2", query.getProductCode(), query.tableCode);

        var filtersStore = query.filtersStore;
        for (var i = 0; i < filtersStore.count() ; i++) {
            var filter = filtersStore.getAt(i);
            if (filter.get('codePath') != "TABLE") {
                ret += Ext.String.format("{0},", this.filterToFormula(filter));
            }
        }
        var outputFieldsStore = query.getOutputFieldsStore();
        for (var i = 0; i < outputFieldsStore.count() ; i++) {
            var outputField = outputFieldsStore.getAt(i);
            ret += Ext.String.format("{0},", this.outputFieldToFormula(outputField));
        }

        return Ext.String.format("={0}(\"{1}{2}\",{3})", this.reportType.toFormula(), ret, "RT=-4154,RF=111111011,AF=1,TP=,", "");
    },

    removeQuoteIfPossible: function(value){
        if (value !== undefined && value.indexOf("'") === 0 && value.length > 1) {
            return value.substring(1);
        } else {
            return value;
        }
    },

    queryFromFormula: function (formula) {
        var me = this;

        var matches = formula.match(/=(.+)\(\"=(.+)\)/);
        if (matches.length === 3) {
	   		var reportTypeInMatch = matches[1];
			var reportContentInMatch = matches[2];            
			this.reportType = EvolveQueryEditor.model.ReportTypeModel.getReportType(reportTypeInMatch);
            var matches1 = reportContentInMatch.match(/(\d+),(\d+),(\w+),(\w+)(?:,\*={P}1|,\*=[YNyn])?(?:,(F=[^,]+,(?:T=[^,]+,)?K=[^,]+))*,?(?:,((?:C=[^,]+?,)?E=-?\d+,(?:X=<sFm2>{_sf_}[\+\-\/\*]\d+(?:\.\d+)?<\/sFm2>,)?(?:S=\(?\d+\)?,)?O=[^,]+))+(,RT=(-?\d)+,RF=([0-1]{9})(?:,AF=[01])?)?(,TP=(\d+%?)?)?(,XLBVal:(\d+)=(.*))?/);
			var productInMatch = matches1[3];
			var tableInMatch = matches1[4];
            this.product = Ext.create('EvolveQueryEditor.model.ProductModel', {
                Code: productInMatch
            });
            
            var filtersStore = this.getFilterStore();
            filtersStore.removeAll();

            //Set table code firstly, so that the following steps can use the table code to take the query. For example, loading the selection list. Otherwsie, the table code will be set in callback after retrieving the super filters.
            // We can now add the table filter ...
            var modelTable = Ext.create('EvolveQueryEditor.model.FilterModel', {
                name: 'Table',
                codePath: 'TABLE',
            });
            filtersStore.add(modelTable);
            this.setTable(tableInMatch, tableInMatch, tableInMatch);

			var regExpForFilter = /(F=[^,]+,(?:T=[^,]+,)?K=[^,]+)/;
            var matches2 = reportContentInMatch.match(new RegExp(regExpForFilter.source, "g"));
            var filterMap = new Ext.util.HashMap();
            for(var i=0; i<matches2.length; i++){
                var matches3 = matches2[i].match(regExpForFilter);
                filterMap.add(matches3[3], { from: me.removeQuoteIfPossible(matches3[1]), to: me.removeQuoteIfPossible(matches3[2]) })
            }

            //Add super filters
            this.getSuperFiltersStore(function (records) {
                for (var rowIndex = 0; rowIndex < records.length; rowIndex++) {
                    if (records[rowIndex].get('from') == '') {
                        records[rowIndex].set('from', undefined);  // No default - so make it really no value
                    }
                    if(filterMap.get(records[rowIndex].get('codePath')) !== undefined){
                        records[rowIndex].set('from', filterMap.get(records[rowIndex].get('codePath')).from);
                        records[rowIndex].set('to', filterMap.get(records[rowIndex].get('codePath')).to);
                    }
                    records[rowIndex].set('superFieldFilter', true);
                    filtersStore.insert(rowIndex, records[rowIndex]);
                }

 
                //Add filters
                me.getMandatoryFiltersStore(function (rs) {
                    for (var row = 0; row < rs.length; row++) {
                        if (rs[row].get('from') == '') {
                            rs[row].set('from', undefined);  // No default - so make it really no value
                        }
                        if (filterMap.get(rs[row].get('codePath')) !== undefined) {
                            rs[row].set('from', filterMap.get(rs[row].get('codePath')).from);
                            rs[row].set('to', filterMap.get(rs[row].get('codePath')).to);
                        }
                        filtersStore.add(rs[row]);
                    }

					//add outputfields
					var outputFieldStore = me.getOutputFieldsStore();
					outputFieldStore.removeAll();
					var outputFiledModels = EvolveQueryEditor.model.OutputFieldModel.parseAllFromString(reportContentInMatch);
					
					//TODO: parseAllFromString triggers multiple async webservice invocation inside. It should delay adding output field to store after all the invocations are finished.
					//further more in this method there're webservice invocations for super field, mandatory fields and output fields. We should make them into one web servcie by
					//passing the formula to the server-side and get all necessary informaiton 
					outputFieldStore.add(outputFiledModels);

                });
            });

            return true;
        }

        return false;
    },

    getProductStore: function () {
        if (EvolveQueryEditor.model.Query.getQueryType() !== undefined) {
            EvolveQueryEditor.store.ProductStore.Instance.load({
                callback: function (records, operation, success) {
                }
            });
        }

        return EvolveQueryEditor.store.ProductStore.Instance;
    },

    getSuperFiltersStore: function(callbackAfterLoad){
        if (EvolveQueryEditor.model.Query.getProductCode() !== undefined) {
            EvolveQueryEditor.store.SuperFieldsStore.Instance.load({
                callback: function (records, operation, success) {
                    callbackAfterLoad(records);
                }
            });
        }

        return EvolveQueryEditor.store.SuperFieldsStore.Instance;
    },

    getMandatoryFiltersStore: function (callbackAfterLoad) {
        if (EvolveQueryEditor.model.Query.getProductCode() !== undefined && EvolveQueryEditor.model.Query.tableCode !== undefined) {
            EvolveQueryEditor.store.MandatoryFieldsStore.Instance.load({
                callback: function (records, operation, success) {
                    callbackAfterLoad(records);
                }
            });
        }

        return EvolveQueryEditor.store.MandatoryFieldsStore.Instance;
    },

    getFilterStore: function () {
        if (EvolveQueryEditor.model.Query.filtersStore === undefined) {
            EvolveQueryEditor.model.Query.filtersStore = Ext.create('EvolveQueryEditor.store.QueryContextStore');
        }
        return EvolveQueryEditor.model.Query.filtersStore;
    }
});