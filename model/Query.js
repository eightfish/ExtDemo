/*
 * File: app/model/Query.js
 *
 * This file was generated by Sencha Architect version 2.2.2.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 4.1.x library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 4.1.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('EvolveQueryEditor.model.Query', {
    extend: 'Ext.Base',

    requires: [
        'EvolveQueryEditor.model.ReportTypeModel',
        'EvolveQueryEditor.model.ProductModel',
        'EvolveQueryEditor.model.FilterModel',
        'EvolveQueryEditor.model.FilterValueModel',
        'EvolveQueryEditor.model.OutputFieldModel',
        'EvolveQueryEditor.store.QueryContextStore',
        'EvolveQueryEditor.store.ProductStore',
        'EvolveQueryEditor.store.MandatoryFieldsStore',
        'EvolveQueryEditor.model.SortingTypeModel',
        'EvolveQueryEditor.model.OutputFieldModel'
    ],
    singleton: true,
    tableCode: '',
    tableName: '',
    tableNamePlusCode: '',
    outputFieldsStore: undefined,

    getFilters: function () {
        var filtersRet = [];
		var filterStore =  EvolveQueryEditor.model.Query.filtersStore;
        if (filterStore !== undefined) {
            for (var i = 0; i <filterStore.count() ; i++) {
                var filter = filterStore.getAt(i);
                if (!filter.isTable() && filter.isSuperFieldFilter() && !Ext.isEmpty(filter.get('from')) ) {
					filtersRet.push(filter.toJsonWithOptions());
                }
            }
        }

        return filtersRet;
    },

    isAllSuperFieldFiltersSet: function () {
        if (EvolveQueryEditor.model.Query.filtersStore != undefined) {
            for (var i = 0; i < EvolveQueryEditor.model.Query.filtersStore.count() ; i++) {
                var filter = EvolveQueryEditor.model.Query.filtersStore.getAt(i);
                if (filter.isSuperFieldFilter() === true && filter.get('from') === undefined) {
                    return false;
                }
            }
        }

        return true;
    },

    getOutputFieldsStore: function () {
        if (this.outputFieldsStore == undefined) {
            this.outputFieldsStore = Ext.create('Ext.data.Store', {
                storeId: 'outputFieldsStore',
                model: "EvolveQueryEditor.model.OutputFieldModel",
                proxy: {
                    type: 'memory',
                    reader: {
                        type: 'json',
                        root: 'items'
                    }
                }
            });
        }

        return this.outputFieldsStore;
    },

    getProductCode: function(){
        return this.product === undefined ? undefined : this.product.data.Code;//this.product.get('Code');
    },

    getQueryType: function () {
        return this.reportType === undefined ? undefined : this.reportType.data.Type;// this.reportType.get("Type");
    },

    clearTable:function(){
        this.tableCode = '';
        this.tableName = '';
        this.tableNamePlusCode = '';
    },

    setTable: function (code, value, tableNamePlusCode) {
        for (var i = 0; i < EvolveQueryEditor.model.Query.filtersStore.count() ; i++) {
            var filter = EvolveQueryEditor.model.Query.filtersStore.getAt(i);
            var model = EvolveQueryEditor.model.Query;
            if (filter.isTable()) {
                // Create a model to hold the selection ...
                var modelSelection = Ext.create('EvolveQueryEditor.model.FilterValueModel', {
                    codePath: "TABLE",
                    valueFrom: value,
                    valueTo: value
                });

                filter.beginEdit();
                filter.setValue(modelSelection);
                filter.set('hasValue', true);
                filter.set('from', code);
                filter.set('to', code);
                filter.endEdit();

                model.tableCode = code;
                model.tableName = value;
                model.tableNamePlusCode = tableNamePlusCode;
                break;
            }
        }
    },

    stringIsEmpty: function (val) {
        return (val === undefined || val == null || val.length <= 0) ? true : false;
    },

    filterToFormula: function (filter) {
        var codePath = filter.get('codePath');
        var from = filter.get('from');
        var to = filter.get('to');
        if (this.stringIsEmpty(to)) {
            return Ext.String.format("F={0},K={1}", from, codePath);
        } else {
            return Ext.String.format("F={0},T={1},K={2}", from, to, codePath);
        }
    },

    outputFieldToFormula: function (outputField) {
        //template:E={0},X=<sFm2>{{_sf_}}{1}</sFm2>,S={2},O={3}"

        var extractValue = outputField.get("extractType");
        var extractIntValue = extractValue.get('intValue');
        if (extractValue === EvolveQueryEditor.model.ExtractionTypeModel.Segment) {
            //Segment will be 10203 if the offset is 2 and length is 3.
            extractIntValue += outputField.get("segmentOffset") * 100;
            extractIntValue += outputField.get("segmentLength");
        }
        //If ReverseSign is true, the - will be added. for example, -2.
        var extractionTypeWithReverseSign = Ext.String.format("{0}{1}", outputField.get("reverseSign") ? "-" : "", extractIntValue);

        var scalingFactor = outputField.get("scalingFactor");

        var sortIndex = outputField.get("sortIndex");        
        var sortingFormulaPart = outputField.get("sortingType").toFormula(sortIndex);
        if(sortingFormulaPart !== '') { 
            sortingFormulaPart = sortingFormulaPart + ",";
        }
        
        var ret = Ext.String.format("{0}{1}{2}{3}", Ext.String.format("E={0},", extractionTypeWithReverseSign), this.stringIsEmpty(scalingFactor) ? "" : Ext.String.format("X=<sFm2>{{_sf_}}{0}</sFm2>,", scalingFactor), sortingFormulaPart, Ext.String.format("O={0}", outputField.get("codePath")));
        return ret;
    },

    queryToFormula: function () {
        var query = this;
		
		var ret = { success: true,
					error: '',
					formula: '' };
		
		var productCode = query.getProductCode();
		if(Ext.isEmpty(productCode)) {
			ret.success = false;
			ret.error = 'productCode';
			return ret;
		}
		
		var tableCode = query.tableCode;
		if(Ext.isEmpty(tableCode)) {
			ret.success = false;
			ret.error = 'tableCode';
			return ret;
		}
		
        var formula = Ext.String.format("{0},{1},{2},{3},", "1", "2", productCode, tableCode);

        var filtersStore = query.filtersStore;
		if(filtersStore.count() === 0) {
			ret.success = false;
			ret.error = 'filtersStore';
			return ret;
		}
		
        for (var i = 0; i < filtersStore.count() ; i++) {
            var filter = filtersStore.getAt(i);
            if (!filter.isTable()) {
                formula += Ext.String.format("{0},", this.filterToFormula(filter));
            }
        }
		
        var outputFieldsStore = query.getOutputFieldsStore();
		if(outputFieldsStore.count() === 0) {
			ret.success = false;
			ret.error = 'outputFieldsStore';
			return ret;
		}
		
        for (var i = 0; i < outputFieldsStore.count() ; i++) {
            var outputField = outputFieldsStore.getAt(i);
            formula += Ext.String.format("{0},", this.outputFieldToFormula(outputField));
        }
		
		ret.formula = Ext.String.format("={0}(\"{1}{2}\",{3})", this.reportType.toFormula(), formula, "RT=-4154,RF=111111011,AF=1,TP=,", "");
        return ret;
    },

    removeQuoteIfPossible: function(value){
        if (value !== undefined && value.indexOf("'") === 0 && value.length > 1) {
            return value.substring(1);
        } else {
            return value;
        }
    },

    queryFromFormula: function (formula) {
        var me = this;

        var matches = formula.match(/=(.+)\(\"=(.+)\)/);
        if (matches.length === 3) {
	   		var reportTypeInMatch = matches[1];
			var reportContentInMatch = matches[2];            
			this.reportType = EvolveQueryEditor.model.ReportTypeModel.getReportType(reportTypeInMatch);
            var matches1 = reportContentInMatch.match(/(\d+),(\d+),(\w+),(\w+)(?:,\*={P}1|,\*=[YNyn])?(?:,(F=[^,]+,(?:T=[^,]+,)?K=[^,]+))*,?(?:,((?:C=[^,]+?,)?E=-?\d+,(?:X=<sFm2>{_sf_}[\+\-\/\*]\d+(?:\.\d+)?<\/sFm2>,)?(?:S=\(?\d+\)?,)?O=[^,]+))+(,RT=(-?\d)+,RF=([0-1]{9})(?:,AF=[01])?)?(,TP=(\d+%?)?)?(,XLBVal:(\d+)=(.*))?/);
			var productInMatch = matches1[3];
			var tableInMatch = matches1[4];
            this.product = Ext.create('EvolveQueryEditor.model.ProductModel', {
                Code: productInMatch
            });
            
            var filtersStore = this.getFilterStore();
            filtersStore.removeAll();

            //Set table code firstly, so that the following steps can use the table code to take the query. For example, loading the selection list. Otherwsie, the table code will be set in callback after retrieving the super filters.
            // We can now add the table filter ...
            var modelTable = Ext.create('EvolveQueryEditor.model.FilterModel', {
                name: 'Table',
                codePath: 'TABLE',
            });
            filtersStore.add(modelTable);
            this.setTable(tableInMatch, tableInMatch, tableInMatch);

			var regExpForFilter = /(F=([^,]+),(?:T=([^,]+),)?K=([^,]+))/;
            var matches2 = reportContentInMatch.match(new RegExp(regExpForFilter.source, "g"));
            var filterMap = new Ext.util.HashMap();
            for(var i=0; i<matches2.length; i++){
                var matches3 = matches2[i].match(regExpForFilter);
                var filterValues = [];
                if (filterMap.containsKey(matches3[4])) {
                    filterValues = filterMap.get(matches3[4]);
                } 
                filterValues.push({ from: me.removeQuoteIfPossible(matches3[2]), to: me.removeQuoteIfPossible(matches3[3]) });
                filterMap.add(matches3[4], filterValues);
            }

            //Add super filters
            this.getSuperFiltersStore(function (records) {
                for (var rowIndex = 0; rowIndex < records.length; rowIndex++) {
					var superFilterModel = records[rowIndex];
                    if (superFilterModel.get('from') == '') {
                        superFilterModel.set('from', undefined);  // No default - so make it really no value
                    }
                    var existedValue = filterMap.get(superFilterModel.get('codePath'));
                    if (existedValue !== undefined && existedValue.length > 0) {
                        superFilterModel.set('from', existedValue[0].from);
                        superFilterModel.set('to', existedValue[0].to);
						//todo: set more properties from existedValue[0]
                        filterMap.remove(existedValue);
                    }
                    records[rowIndex].set('superFieldFilter', true);
                    filtersStore.insert(rowIndex, superFilterModel);
                }

 
                //Add filters
                me.getMandatoryFiltersStore(function (rs) {
                    for (var row = 0; row < rs.length; row++) {
                        if (rs[row].get('from') == '') {
                            rs[row].set('from', undefined);  // No default - so make it really no value
                        }
                        var existedValue = filterMap.get(rs[row].get('codePath'))
                        if (existedValue !== undefined && existedValue.length > 0) {
                            rs[row].set('from', existedValue[0].from);
                            rs[row].set('to', existedValue[0].to);
							//todo: set more properties from existedValue[0]
                        }
                        filtersStore.add(rs[row]);
                        //Add same code path optional filters
                        if (existedValue.length > 1) {
                            Ext.each(existedValue, function (filterValue, index) {
                                if (index > 0) {
                                    var newFilter = {
                                        name: rs[row].get('name'),
                                        from: filterValue.from,
                                        to: filterValue.to,
                                        codePath: rs[row].get('codePath'),
                                        single: rs[row].get('single'),
                                        dataType: rs[row].get('dataType'),
                                        allowSegments: rs[row].get('allowSegments'),
                                        lookupCategory: rs[row].get('lookupCategory'),
                                        allowMultipleFilters: rs[row].get('allowMultipleFilters'),
                                        isOptionalFilter: true
                                    }
                                    filtersStore.add(newFilter);
                                }
                            });
                        }
                        filterMap.remove(existedValue);

                    }

                    //Add all left optional filters
                    filterMap.each(function (codePath, filterValues) {
                        Ext.Ajax.request({
                            url: EvolveQueryEditor.model.Query.serverUrlBase + '&method=BringOutFieldDetails',
                            jsonData: {
                                clientToken: EvolveQueryEditor.model.Query.clientToken,
                                codePath: codePath,
                                async: false,
                                query: {
                                    productCode: EvolveQueryEditor.model.Query.getProductCode(),
                                    tableCode: EvolveQueryEditor.model.Query.tableCode,
                                    mode: EvolveQueryEditor.model.Query.getQueryType(),
                                    filters: EvolveQueryEditor.model.Query.getFilters()
                                }
                            },
                            success: function (response) {
                                var filterData = Ext.decode(response.responseText);
                                Ext.each(filterValues, function (filterValue, index) {
                                    newFilter = {
                                        name: filterData.name,
                                        from: filterValue.from,
                                        to: filterValue.to,
                                        codePath: filterData.codePath,
                                        //valueFrom: filterData.from,
                                        //valueTo: filterData.to,
                                        single: filterData.single,
                                        dataType: filterData.dataType,
                                        allowSegments: filterData.allowSegments,
                                        lookupCategory: filterData.lookupCategory,
                                        allowMultipleFilters: filterData.allowMultipleFilters,
                                        isOptionalFilter: true
                                    }
                                    filtersStore.add(newFilter);

                                });
                            },
                            failure: function (response, options) {
                                alert(response.statusText);
                            }
                        });

                    });

					//add outputfields
					var outputFieldStore = me.getOutputFieldsStore();
					outputFieldStore.removeAll();
					var outputFiledModels = EvolveQueryEditor.model.OutputFieldModel.parseAllFromString(reportContentInMatch);
					
					//TODO: parseAllFromString triggers multiple async webservice invocation inside. It should delay adding output field to store after all the invocations are finished.
					//further more in this method there're webservice invocations for super field, mandatory fields and output fields. We should make them into one web servcie by
					//passing the formula to the server-side and get all necessary informaiton 
					outputFieldStore.add(outputFiledModels);

                });
            });

            return true;
        }

        return false;
    },

    getProductStore: function () {
        if (EvolveQueryEditor.model.Query.getQueryType() !== undefined) {
            EvolveQueryEditor.store.ProductStore.Instance.load({
                callback: function (records, operation, success) {
                }
            });
        }

        return EvolveQueryEditor.store.ProductStore.Instance;
    },

    getSuperFiltersStore: function(callbackAfterLoad){
        if (EvolveQueryEditor.model.Query.getProductCode() !== undefined) {
            EvolveQueryEditor.store.SuperFieldsStore.Instance.load({
                callback: function (records, operation, success) {
                    callbackAfterLoad(records);
                }
            });
        }

        return EvolveQueryEditor.store.SuperFieldsStore.Instance;
    },

    getMandatoryFiltersStore: function (callbackAfterLoad) {
        if (EvolveQueryEditor.model.Query.getProductCode() !== undefined && EvolveQueryEditor.model.Query.tableCode !== undefined) {
            EvolveQueryEditor.store.MandatoryFieldsStore.Instance.load({
                callback: function (records, operation, success) {
                    callbackAfterLoad(records);
                }
            });
        }

        return EvolveQueryEditor.store.MandatoryFieldsStore.Instance;
    },

    getFilterStore: function () {
        if (EvolveQueryEditor.model.Query.filtersStore === undefined) {
            EvolveQueryEditor.model.Query.filtersStore = Ext.create('EvolveQueryEditor.store.QueryContextStore');
        }
        return EvolveQueryEditor.model.Query.filtersStore;
    }
});